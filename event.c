/* Event aggregator, also serves as event cache, remembering GW and IFUP states
 *
 * Copyright (c) 2015  Joachim Nilsson <troglobit@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include <libgen.h>
#include <paths.h>
#include <stdio.h>

#include "config.h"		/* Generated by configure script */
#include "libite/lite.h"

#include "finit.h"
#include "service.h"

#define EV_PATH _PATH_VARRUN "finit/ev"

static inline const char *__ev_path(const char *name)
{
	static char file[64];

	snprintf(file, sizeof(file), EV_PATH "/%s", name);
	return file;
}

static const char *event_val_parse(const char *val, const char *old)
{
	static char seq[16];
	int old_seq;

	if (strcmp(val, "+"))
		return val;

	if (!old)
		return "seq 0";

	if (strncmp(old, "seq ", 4))
		return val;

	old_seq = strtol(&old[4], NULL, 0);
	if (old_seq < 0)
		return val;

	snprintf(seq, sizeof(seq), "seq %d", old_seq + 1);
	return seq;
}

static int event_exist(const char *name)
{
	return fexist((char *)__ev_path(name));
}

static const char *event_get(const char *name)
{
	static char val[64];

	FILE *fp;
	char *ret;

	fp = fopen(__ev_path(name), "r");
	if (!fp)
		return NULL;

	ret = fgets(val, sizeof(val), fp);
	fclose(fp);
	return ret ? : "";
}

int event_set(const char *name, const char *val)
{
	const char *old;
	FILE *fp;

	old = event_get(name);

	_d("%s: \"%s\" -> \"%s\"", name, old, val);

	if (!val)
		unlink(__ev_path(name));
	else {
		char *path;

		path = strdup(__ev_path(name));
		makepath(dirname(path));
		free(path);

		fp = fopen(__ev_path(name), "w+");
		if (!fp)
			goto err;

		val = event_val_parse(val, old);
		if (fputs(val, fp) < 0)
			goto err_close;

		fclose(fp);
	}

	if (!old || !val)
		return old != val;

	return strcmp(old, val);

err_close:
	fclose(fp);
err:
	_pe("Unable to store event %s", name);
	return 0;
}

static int event_split_set(char *evstr)
{
	char *name, *val;

	if (!evstr)
		return 0;

	name = strtok(evstr, ":");
	val  = strtok(NULL, ":");

	if (name[0] == '~')
		return event_set(&name[1], NULL);
	else
		return event_set(name, val? : "");
}

static int event_met(const char *evstr)
{
	static char dup[64];

	char *delim, *name, *val;
	const char *act;

	delim = strrchr(evstr, ':');
	/* no argument, just stat to see if event is set */
	if (!delim) {
		if (evstr[0] == '~')
			return !event_exist(&evstr[1]);
		else
			return event_exist(evstr);
	}

	/* ok, we need to compare the value as well */
	strncpy(dup, evstr, sizeof(dup));
	name = strtok(dup, ":");
	val  = strtok(NULL, ":");
	act  = event_get(name);

	if (!act)
		return 0;

	return !strcmp(val, act);
}

int event_all_met(const char *evstrs)
{
	char *ev, *evs;
	int met = 1;

	if (!evstrs || !evstrs[0])
		return 1;

	evs = strdup(evstrs);
	for (ev = strtok(evs, ","); met && ev; ev = strtok(NULL, ",")) {
		met &= event_met(ev);
		_d("ev:\"%s\" met:%d", ev, met);
	}
	free(evs);
	return met;
}

static int event_matches(const char *evstrs, const char *msg)
{
	char *at;

	if (!msg)
		return 0;

	if (msg[0] == '~')
		msg++;

	at = strstr(evstrs, msg);
	if (!at)
		return 0;
	else if (at == evstrs)
		return 1;
	else if (at[-1] == ',')
		return 1;
	else if (at[-2] == ',' && at[-1] == '~')
		return 1;

	return 0;
}

/*
 * Dispatch an event
 *
 * Called by initctl (via api.c) or plugins/netlink.so
 * May also cache for future reference.
 */
void event_dispatch(char *msg)
{
	int change;
	svc_t *svc;

	if (!msg) {
		_e("Invalid message received.");
		return;
	}

	_d("%s", msg);

	change = event_split_set(msg);
	if (!change) {
		_d("Nothing to do");
		return;
	}

	/* Iterate over svc_t and call service_restart() for event matches */
	for (svc = svc_iterator(1); svc; svc = svc_iterator(0)) {
		if (svc->type != SVC_TYPE_SERVICE  ||
		    !event_matches(svc->events, msg)) {
			/* _d("No match for %s in service %s", msg, svc->cmd); */
			continue;
		}

		_d("%s: match <%s> %s", msg, svc->events, svc->cmd);
		service_dance(svc, 1);
	}
}

/**
 * Local Variables:
 *  version-control: t
 *  indent-tabs-mode: t
 *  c-file-style: "linux"
 * End:
 */
